#!/bin/bash

set -Eeuo pipefail

# TODO: test this
#if [[ "${1:-}" == "--verbose" ]]; then
#  echo "Verbose mode enabled."
#  set -x
#fi

function getJavaMem() {
  # get JVM memory in MiB by getting total memory from /proc/meminfo
  # and multiplying by java_mem_fraction

  local mem_fraction=${java_mem_fraction:=0.85}
  cat /proc/meminfo | \
    awk -v MEM_FIELD="$1" -v frac="${mem_fraction}" '{
      f[substr($1, 1, length($1)-1)] = $2
    } END {
      printf "%dM", f[MEM_FIELD] * frac / 1024
    }'
}
JVM_MAX_MEM=$(getJavaMem MemTotal)
echo "JVM memory: $JVM_MAX_MEM"

inputs_json=${1}
output_dir=${2:-""}

inputs_json="$(realpath ${inputs_json})"

if [ -z "${output_dir}" ]; then
  output_dir=$(mktemp -d output_make_bincov_matrix_XXXXXXXX)
else
  mkdir -p "${output_dir}"
fi
output_dir="$(realpath ${output_dir})"

merged_bincov="batch.RD.txt.gz"
merged_bincov_idx="${merged_bincov}.tbi" # this file is auto-generated by PrintSVEvidence

working_dir=$(mktemp -d wd_make_bincov_matrix_XXXXXXXX)
working_dir="$(realpath ${working_dir})"
cd "${working_dir}"

readarray -t count_files < <(jq -r '.count_files[]' "${inputs_json}")

# These files need to have the `.list` extension (gatk requirement)
evidence_files_list="evidence_files.list"
samples_filename="samples.list"

binsize=$(jq -r ".binsize" "${inputs_json}")
bincov_matrix=$(jq -r ".bincov_matrix" "${inputs_json}")
reference_dict=$(jq -r ".reference_dict" "${inputs_json}")

bincov_matrix_samples=$(jq -r ".bincov_matrix_samples" "${inputs_json}")
printf "%s\n" "${bincov_matrix_samples[@]}" > "${samples_filename}"

for filename in "${count_files[@]}"; do
  case "${filename}" in
    *.counts.tsv.gz)
      sample_id="${filename%.counts.tsv.gz}"
      output_filename="${sample_id}.rd.txt.gz"

      java "-Xmx${JVM_MAX_MEM}" -jar /opt/gatk.jar \
        ConvertCountsToDepthFile \
        --counts-filename "${filename}" \
        --output "${output_filename}"

      echo "${output_filename}" >> "${evidence_files_list}"
      ;;

    *.rd.tsv.gz)
      echo filename >> "${evidence_files_list}"
      ;;

    *)
      echo "File extension does not match *.counts.tsv.gz or *.rd.tsv.gz."
      ;;
  esac
done

java "-Xmx${JVM_MAX_MEM}" -jar /opt/gatk.jar \
  PrintSVEvidence \
    -F "${evidence_files_list}" \
    --sample-names "${samples_filename}" \
    --sequence-dictionary "${reference_dict}" \
    --output "${merged_bincov}"

exit()

# we discussed offline the following is not needed

# ---------------------------
# --------- SetBins ---------
# ---------------------------
#
## kill the dictionary | kill the header | adjust to bed format: 0-based half-open intervals
#zcat "${first_count_file}" \
#  | sed '/^@/d' \
#  | sed '/^CONTIG	START	END	COUNT$/d' \
#  | sed '/^#/d' \
#  | awk -v x="1" 'BEGIN{OFS="\t"}{$2=$2-x; print $1,$2,$3}' > tmp_locs
#
## determine bin size, and drop all bins not exactly equal to this size
#if [[ "${binsize}" == "null" ]]; then
#  # use the most common bin size from the bins
#  binsize=$(
#    sed -n '1,1000p' tmp_locs | awk '{ print $3-$2 }' \
#    | sort | uniq -c | sort -nrk1,1 \
#    | sed -n '1p' | awk '{ print $2 }'
#  )
#fi
#
## store binsize where cromwell can read it
## TODO: the folloiwng is not needed, just output the defined bin size.
##echo "${binsize}" > ~{binsize_output_file_name}
#
## write final bed file with header, and compress it
#awk -v FS="\t" -v b="${binsize}" 'BEGIN{ print "#Chr\tStart\tEnd" } { if ($3-$2==b) print $0 }' tmp_locs \
#    | bgzip -c \
#    > "${bin_file_name}"
#
## if bincov_matrix_samples was passed, convert to tab-separated string
#bincov_header_file_name="bincov_header_file.tsv"
#if [[ "${bincov_matrix_samples}" != "null" ]]; then
#  echo "${bincov_matrix_samples[@]}" | jq -r '. | @tsv' > "${bincov_header_file_name}"
#else
#  touch "${bincov_header_file_name}"
#fi
#
#
#
##bin_locs="${output_dir}/locs.bed.gz"
##mv bin_file_name bin_locs
##bincov_matrix_header_file="${output_dir}/bincov_header_file.tsv"
#
#
## ------------------------------------------------------------------------ continue from here
#array_length=${#my_array[@]}
#
## C-style loop from 0 to array_length - 1
#for (( i=0; i<${array_length}; i++ )); do
#...
#done
## ----------------------------------------------------------------------- continue to here
#
#
## -------------------------------------------
## --------- MakeBincovMatrixColumns ---------
## -------------------------------------------
#
#bincov_file_name="$(basename "${count_file}" .tsv.gz).RD.txt.gz"
#
#TMP_BED=$(mktemp -p "${working_dir}" XXXXXXXXXX.tmp.bed)
#printf "#Chr\tStart\tEnd\t%s\n" "${sample}" > $TMP_BED
#zcat "${count_file}" \
#  | sed '/^@/d' \
#  | sed '/^CONTIG	START	END	COUNT$/d' \
#  | sed '/^#/d' \
#  | awk -v x=1 -v b="${binsize}" \
#    'BEGIN{OFS="\t"}{$2=$2-x; if ($3-$2==b) print $0}' \
#  >> "${TMP_BED}"
#
#if ! cut -f1-3 "${TMP_BED}" | cmp <(bgzip -cd "${bin_locs}"); then
#  echo "${count_file} has different intervals than ${bin_locs}"
#  exit 1
#fi
#cut -f4- "${TMP_BED}" | bgzip -c >> "${bincov_file_name}"
#
#
#
#
#outputs_filename="${output_dir}/outputs.json"
##outputs_json=$(jq -n \
##  --arg bin_locs "${bin_locs}" \
##
##  '{counts: $c}' )
##echo "${outputs_json}" > "${outputs_filename}"
##cp "${outputs_filename}" "${outputs_json_filename}"

